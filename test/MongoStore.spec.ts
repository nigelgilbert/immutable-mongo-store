import { expect } from 'chai';
import 'mocha';
import { MongoStore } from '../src/MongoStore';
import { Collection, ObjectId, FindAndModifyWriteOpResultObject } from 'mongodb';
import { IMock, Mock, It, Times } from 'typemoq';
import { MockBase } from 'typemoq/MockBase';
import { recordify } from 'typed-immutable-record';
import { User, UserRecord } from './UserRecord';
describe('MongoStore', () => {

    // test data
    const _id = new ObjectId('5a803d0be8854d4f043f73d8');
    const name = 'Nigel';
    const email = 'nigelcodes@gmail.com';
    const age = 23;
    const mutations = [];
    const mockUser: User = { _id, name, email, age, mutations };
    let query = undefined;

    describe('updateRecord', () => {

        it('should not update if record is not changed', async () => {
            const mockCollection: IMock<Collection> = Mock.ofType<Collection>();

            mockCollection.setup(c => c.findOne(It.isValue({ _id }), It.isAny()))
                .returns(() => Promise.resolve(mockUser));
            mockCollection.setup(c => c.findOneAndUpdate(It.isValue({ _id }), It.isAny()))
                .returns(() => undefined)
                .verifiable(Times.never());

            const store = new MongoStore<User, UserRecord>(mockCollection.object);
            const user = await store.getRecord(_id);
            const result = await store.updateRecord(user);

            expect(result).to.equal(user);
            mockCollection.verifyAll();
        });

        describe('Mongo queries generated by updateRecord', () => {

            // factory for mock'ed Mongo collection to test against
            function getMockMongoCollection() {
                const mockCollection: IMock<Collection> = Mock.ofType<Collection>();

                mockCollection.setup(c => c.findOne(It.isValue({ _id }), It.isAny()))
                    .returns(() => Promise.resolve(mockUser));
                mockCollection.setup(c => c.findOneAndUpdate(It.isValue({ _id }), It.isAny()))
                    .callback((f, q) => query = q)
                    .returns(() => Promise.resolve(undefined))
                    .verifiable(Times.once());

                return mockCollection;
            }

            describe('$set and $unset properties', () => {
                it('should produce a valid $set on prop change', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const updated = user.set('name', 'Timmy');
                    await store.updateRecord(updated);

                    mockCollection.verifyAll();
                    expect(query.$set).to.deep.equal({ 'name': 'Timmy' });
                });

                it('should produce a valid $unset on prop removal', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const updated = user.set('name', undefined);
                    await store.updateRecord(updated);

                    mockCollection.verifyAll();
                    expect(query.$unset).to.haveOwnProperty('name');
                });

                it('should produce a valid $unset and $set on change + removal', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const update1 = user.set('name', undefined);
                    const update2 = update1.set('email', 'test@gmail.com');
                    await store.updateRecord(update2);

                    mockCollection.verifyAll();
                    expect(query.$unset).to.haveOwnProperty('name');
                    expect(query.$set).to.deep.equal({ 'email': 'test@gmail.com' });
                });
            });

            describe('$pushed mutations', () => {
                 it('should $push the correct diff\'ed mutation on prop change', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const updated = user.set('name', 'Timmy');
                    await store.updateRecord(updated);

                    mockCollection.verifyAll();
                    expect(query.$push.mutations[0]).to.be.a('number');
                    expect(query.$push.mutations[1]).to.deep.equal({ 'name': 'Timmy' });
                });

                it('should $push the correct diff\'ed mutation on prop removal', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const updated = user.set('name', undefined);
                    await store.updateRecord(updated);

                    mockCollection.verifyAll();
                    expect(query.$push.mutations[0]).to.be.a('number');
                    expect(query.$push.mutations[1]).to.deep.equal({ 'name': '' });
                });

                it('should $push the correct diff\'ed mutation on prop removal + change', async () => {
                    const mockCollection = getMockMongoCollection();
                    const store = new MongoStore<User, UserRecord>(mockCollection.object);

                    const user = await store.getRecord(_id);
                    const update1 = user.set('name', undefined);
                    const update2 = update1.set('email', 'test@gmail.com');
                    await store.updateRecord(update2);

                    mockCollection.verifyAll();
                    expect(query.$push.mutations[0]).to.be.a('number');
                    expect(query.$push.mutations[1]).to.deep.equal({ email: 'test@gmail.com', name: '' });
                });
            });
        });
    });
});